# SQL Cheatsheet

## 1. Basic DDL (Data Definition Language)

### Create Table

```sql
CREATE TABLE table_name (
    column_name DATA_TYPE CONSTRAINTS,
    column_name DATA_TYPE CONSTRAINTS
);

-- Example
CREATE TABLE employees (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    salary DECIMAL(10, 2),
    dept_id INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (dept_id) REFERENCES departments(id)
);
```

### Data Types

```sql
INT, BIGINT, SMALLINT, TINYINT        -- Integers
DECIMAL(10, 2), FLOAT, DOUBLE          -- Numbers with decimals
VARCHAR(50), CHAR(10), TEXT            -- Strings
DATE, TIME, TIMESTAMP, DATETIME        -- Date/Time
BOOLEAN                                 -- True/False
JSON                                    -- JSON data
BLOB                                    -- Binary data
```

### Constraints

```sql
PRIMARY KEY       -- Unique identifier
FOREIGN KEY       -- Reference to another table
NOT NULL          -- Column must have value
UNIQUE            -- All values unique
DEFAULT value     -- Default value if not provided
CHECK condition   -- Validate data
AUTO_INCREMENT    -- Auto generate value
```

### Alter Table

```sql
ALTER TABLE table_name ADD COLUMN column_name DATA_TYPE;
ALTER TABLE table_name DROP COLUMN column_name;
ALTER TABLE table_name MODIFY COLUMN column_name DATA_TYPE;
ALTER TABLE table_name RENAME TO new_name;
ALTER TABLE table_name ADD CONSTRAINT pk_name PRIMARY KEY (id);
```

### Drop/Truncate

```sql
DROP TABLE table_name;           -- Delete table structure + data
TRUNCATE TABLE table_name;       -- Delete data only (faster)
DELETE FROM table_name;          -- Delete rows (slower, logged)
```

---

## 2. DML - SELECT Queries

### Basic SELECT

```sql
SELECT column1, column2 FROM table_name;
SELECT * FROM table_name;                        -- All columns
SELECT DISTINCT country FROM customers;          -- Unique values
```

### WHERE Clause

```sql
SELECT * FROM employees WHERE salary > 50000;
SELECT * FROM employees WHERE name = 'John';
SELECT * FROM employees WHERE salary BETWEEN 40000 AND 60000;
SELECT * FROM employees WHERE dept_id IN (1, 2, 3);
SELECT * FROM employees WHERE name LIKE 'J%';   -- Starts with J
SELECT * FROM employees WHERE name LIKE '%n';   -- Ends with n
SELECT * FROM employees WHERE age IS NULL;
SELECT * FROM employees WHERE age IS NOT NULL;
```

### Operators

```sql
=, !=, <>, <, >, <=, >=              -- Comparison
AND, OR, NOT                          -- Logical
LIKE, IN, BETWEEN, IS NULL            -- Special
```

### ORDER BY

```sql
SELECT * FROM employees ORDER BY salary;        -- Ascending
SELECT * FROM employees ORDER BY salary DESC;   -- Descending
SELECT * FROM employees ORDER BY dept_id, salary DESC;  -- Multiple
```

### LIMIT / OFFSET

```sql
SELECT * FROM employees LIMIT 10;           -- First 10 rows
SELECT * FROM employees LIMIT 10 OFFSET 5;  -- Skip 5, get 10
SELECT * FROM employees LIMIT 5, 10;         -- MySQL: skip 5, get 10
```

### Aggregate Functions

```sql
SELECT COUNT(*) FROM employees;              -- Total count
SELECT COUNT(DISTINCT dept_id) FROM employees;
SELECT SUM(salary) FROM employees;
SELECT AVG(salary) FROM employees;
SELECT MAX(salary), MIN(salary) FROM employees;
```

### GROUP BY & HAVING

```sql
SELECT dept_id, COUNT(*) as emp_count
FROM employees
GROUP BY dept_id;

SELECT dept_id, AVG(salary) as avg_sal
FROM employees
GROUP BY dept_id
HAVING AVG(salary) > 50000;
```

### CASE Statement

```sql
SELECT name,
    CASE
        WHEN salary > 60000 THEN 'High'
        WHEN salary > 40000 THEN 'Medium'
        ELSE 'Low'
    END as salary_grade
FROM employees;
```

---

## 3. JOINs

### INNER JOIN

```sql
SELECT e.name, d.dept_name
FROM employees e
INNER JOIN departments d ON e.dept_id = d.id;
```

### LEFT JOIN

```sql
SELECT e.name, d.dept_name
FROM employees e
LEFT JOIN departments d ON e.dept_id = d.id;
```

### RIGHT JOIN

```sql
SELECT e.name, d.dept_name
FROM employees e
RIGHT JOIN departments d ON e.dept_id = d.id;
```

### FULL OUTER JOIN

```sql
SELECT e.name, d.dept_name
FROM employees e
FULL OUTER JOIN departments d ON e.dept_id = d.id;
```

### CROSS JOIN

```sql
SELECT e.name, p.project_name
FROM employees e
CROSS JOIN projects p;
```

### SELF JOIN

```sql
SELECT e1.name as employee, e2.name as manager
FROM employees e1
LEFT JOIN employees e2 ON e1.manager_id = e2.id;
```

---

## 4. Subqueries

### Scalar Subquery

```sql
SELECT name, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);
```

### IN Subquery

```sql
SELECT name
FROM employees
WHERE dept_id IN (SELECT id FROM departments WHERE location = 'NYC');
```

### EXISTS Subquery

```sql
SELECT DISTINCT d.dept_name
FROM departments d
WHERE EXISTS (
    SELECT 1 FROM employees e WHERE e.dept_id = d.id AND e.salary > 60000
);
```

### FROM Subquery

```sql
SELECT avg_salary
FROM (
    SELECT dept_id, AVG(salary) as avg_salary
    FROM employees
    GROUP BY dept_id
) dept_salaries
WHERE avg_salary > 50000;
```

---

## 5. Set Operations

```sql
SELECT id FROM employees WHERE dept_id = 1
UNION                              -- Combines, removes duplicates
SELECT id FROM employees WHERE salary > 100000;

SELECT id FROM employees WHERE dept_id = 1
UNION ALL                          -- Combines, keeps duplicates
SELECT id FROM employees WHERE salary > 100000;

SELECT id FROM employees WHERE dept_id = 1
INTERSECT                          -- Common rows
SELECT id FROM employees WHERE salary > 100000;

SELECT id FROM employees WHERE dept_id = 1
EXCEPT                             -- First minus second
SELECT id FROM employees WHERE salary > 100000;
```

---

## 6. Window Functions

### ROW_NUMBER & RANK

```sql
SELECT name, salary,
    ROW_NUMBER() OVER (ORDER BY salary DESC) as row_num,
    RANK() OVER (ORDER BY salary DESC) as rank,
    DENSE_RANK() OVER (ORDER BY salary DESC) as dense_rank
FROM employees;
```

### Partition By

```sql
SELECT name, dept_id, salary,
    ROW_NUMBER() OVER (PARTITION BY dept_id ORDER BY salary DESC) as dept_rank
FROM employees;
```

### Aggregate with Window

```sql
SELECT name, salary,
    SUM(salary) OVER (PARTITION BY dept_id) as dept_total,
    AVG(salary) OVER (PARTITION BY dept_id) as dept_avg
FROM employees;
```

### LAG & LEAD

```sql
SELECT name, salary,
    LAG(salary) OVER (ORDER BY hire_date) as prev_salary,
    LEAD(salary) OVER (ORDER BY hire_date) as next_salary
FROM employees;
```

---

## 7. DML - INSERT, UPDATE, DELETE

### INSERT

```sql
INSERT INTO employees (name, salary, dept_id)
VALUES ('John', 50000, 1);

INSERT INTO employees (name, salary, dept_id)
VALUES
    ('John', 50000, 1),
    ('Jane', 60000, 2);

INSERT INTO employees SELECT * FROM temp_employees;
```

### UPDATE

```sql
UPDATE employees SET salary = 55000 WHERE id = 1;

UPDATE employees
SET salary = salary * 1.1
WHERE dept_id = 2;

UPDATE employees e
SET salary = (SELECT AVG(salary) FROM employees)
WHERE e.dept_id = 1;
```

### DELETE

```sql
DELETE FROM employees WHERE id = 1;
DELETE FROM employees WHERE dept_id = 2;
```

---

## 8. Indexes

```sql
CREATE INDEX idx_name ON employees(name);
CREATE UNIQUE INDEX idx_email ON users(email);
CREATE INDEX idx_composite ON employees(dept_id, salary);
DROP INDEX idx_name;
SHOW INDEX FROM employees;
```

---

## 9. Views

```sql
CREATE VIEW high_earners AS
SELECT name, salary, dept_id
FROM employees
WHERE salary > 60000;

SELECT * FROM high_earners;

DROP VIEW high_earners;
```

---

## 10. Transactions

```sql
BEGIN TRANSACTION;
-- or
START TRANSACTION;

UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

COMMIT;           -- Save changes
-- or
ROLLBACK;         -- Undo changes

SAVEPOINT sp1;
-- Some operations
ROLLBACK TO sp1;  -- Rollback to savepoint
```

---

## 11. String Functions

```sql
UPPER(str)                    -- Convert to uppercase
LOWER(str)                    -- Convert to lowercase
LENGTH(str)                   -- String length
SUBSTRING(str, start, len)    -- Extract substring
CONCAT(str1, str2, ...)       -- Concatenate strings
TRIM(str)                     -- Remove leading/trailing spaces
REPLACE(str, old, new)        -- Replace substring
INSTR(str, substr)            -- Find position of substring
LTRIM(str), RTRIM(str)        -- Remove left/right spaces
```

---

## 12. Date Functions

```sql
CURRENT_DATE                          -- Today's date
CURRENT_TIME                          -- Current time
CURRENT_TIMESTAMP                     -- Date and time
DATE_ADD(date, INTERVAL 1 DAY)        -- Add days
DATE_SUB(date, INTERVAL 1 MONTH)      -- Subtract months
DATEDIFF(date1, date2)                -- Days between dates
DATE_FORMAT(date, '%Y-%m-%d')         -- Format date
YEAR(date), MONTH(date), DAY(date)    -- Extract parts
WEEK(date), QUARTER(date)             -- Week/Quarter
LAST_DAY(date)                        -- Last day of month
```

---

## 13. Numeric Functions

```sql
ABS(num)           -- Absolute value
ROUND(num, decimals)     -- Round
CEIL(num), FLOOR(num)    -- Ceiling, Floor
SQRT(num)          -- Square root
POWER(num, exp)    -- Power
MOD(num1, num2)    -- Modulo/Remainder
RAND()             -- Random number 0-1
```

---

## 14. NULL Handling

```sql
COALESCE(val1, val2, val3)     -- First non-null value
IFNULL(val, default)            -- Alternative default if null
NULLIF(val1, val2)              -- Return NULL if equal
```

---

## 15. LIKE Pattern Matching

```sql
%      -- Any number of characters
_      -- Single character

WHERE name LIKE 'J%'       -- Starts with J
WHERE name LIKE '%son'     -- Ends with son
WHERE name LIKE 'J_hn'     -- J, any char, h, n
WHERE name LIKE '%oh%'     -- Contains oh
```

---

## 16. Database Optimization

### Query Performance

```sql
EXPLAIN SELECT * FROM employees WHERE salary > 50000;

-- Use indexes on frequently filtered columns
-- Avoid SELECT *, specify needed columns
-- Use LIMIT for large result sets
-- Partition large tables
```

### Common Anti-Patterns to Avoid

```sql
-- ❌ Bad: Avoid functions on indexed columns
WHERE YEAR(hire_date) = 2023

-- ✅ Good: Use range
WHERE hire_date >= '2023-01-01' AND hire_date < '2024-01-01'

-- ❌ Bad: Avoid wildcard at start
WHERE name LIKE '%John%'

-- ✅ Good: Use prefix matching for index
WHERE name LIKE 'John%'

-- ❌ Bad: Avoid SELECT *
SELECT * FROM large_table

-- ✅ Good: Select needed columns
SELECT id, name FROM large_table
```

---

## 17. Common Patterns

### Pagination

```sql
SELECT * FROM employees
ORDER BY id
LIMIT 10 OFFSET (page - 1) * 10;
```

### Top N per Group

```sql
SELECT dept_id, name, salary
FROM (
    SELECT dept_id, name, salary,
           ROW_NUMBER() OVER (PARTITION BY dept_id ORDER BY salary DESC) as rn
    FROM employees
) ranked
WHERE rn <= 3;
```

### Running Total

```sql
SELECT name, salary,
    SUM(salary) OVER (ORDER BY hire_date) as running_total
FROM employees;
```

### Percentage of Total

```sql
SELECT name, salary,
    ROUND(100.0 * salary / SUM(salary) OVER (), 2) as pct_of_total
FROM employees;
```

---

## 18. Important Notes

- **SQL is case-insensitive** for keywords but **case-sensitive for data** (depends on collation)
- **Use aliases** for better readability: `SELECT COUNT(*) as total_count`
- **Comment syntax**: `-- Line comment` or `/* Block comment */`
- **Always use parameterized queries** to prevent SQL injection
- **Index foreign keys** to speed up joins
- **Use EXPLAIN** to analyze query performance
- **Transactions ensure data consistency** across multiple operations
- **Window functions** are powerful for analytics without grouping
